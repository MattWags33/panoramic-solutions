{
  "schema_version": "1.0.0",
  "last_updated": "2025-11-05T01:00:00Z",
  "type": "ARCHITECTURE",
  "metadata": {
    "project": "Panoramic Solutions - PPM Tool Analytics",
    "maintainer": "Parker Gawne",
    "mcp_compatible": true,
    "description": "IP-Based Session Deduplication Strategy"
  },
  "overview": {
    "strategy": "One database record per IP address, updated over time",
    "goal": "Cleaner data - same person = one row, always up-to-date",
    "benefit": "No duplicate records when users clear cache/cookies"
  },
  "how_it_works": {
    "scenario_1_new_user": {
      "description": "User visits for the first time",
      "ip_address": "203.0.113.45",
      "steps": [
        {
          "step": 1,
          "location": "Frontend",
          "action": "Generate new session_id (UUID) and store in localStorage"
        },
        {
          "step": 2,
          "location": "Frontend",
          "action": "Call track_page_view(session_id, path, ip_address, ...)"
        },
        {
          "step": 3,
          "location": "Backend (RPC)",
          "action": "Check: Does IP 203.0.113.45 exist in database?",
          "result": "NO"
        },
        {
          "step": 4,
          "location": "Backend (RPC)",
          "action": "INSERT new row with session_id and IP address"
        },
        {
          "step": 5,
          "location": "Backend (RPC)",
          "action": "Return: {success: true, session_id: 'abc-123', is_new_session: true}"
        },
        {
          "step": 6,
          "location": "Frontend",
          "action": "localStorage already has correct session_id - no update needed"
        }
      ],
      "database_state": {
        "rows_created": 1,
        "session_id": "abc-123",
        "ip_address": "203.0.113.45",
        "first_seen_at": "2025-11-05 10:00:00",
        "last_seen_at": "2025-11-05 10:00:00",
        "total_page_views": 1
      }
    },
    "scenario_2_returning_user_same_session": {
      "description": "Same user refreshes page (localStorage intact)",
      "ip_address": "203.0.113.45",
      "steps": [
        {
          "step": 1,
          "location": "Frontend",
          "action": "Read session_id from localStorage: 'abc-123'"
        },
        {
          "step": 2,
          "location": "Frontend",
          "action": "Call track_page_view('abc-123', path, ip_address, ...)"
        },
        {
          "step": 3,
          "location": "Backend (RPC)",
          "action": "Check: Does IP 203.0.113.45 exist?",
          "result": "YES - found session_id 'abc-123'"
        },
        {
          "step": 4,
          "location": "Backend (RPC)",
          "action": "UPDATE existing row: last_seen_at = NOW(), total_page_views++",
          "note": "Preserves all existing data (criteria_rankings, tools_clicked, etc.)"
        },
        {
          "step": 5,
          "location": "Backend (RPC)",
          "action": "Return: {success: true, session_id: 'abc-123', is_new_session: false}"
        },
        {
          "step": 6,
          "location": "Frontend",
          "action": "session_id matches localStorage - no update needed"
        }
      ],
      "database_state": {
        "rows_created": 0,
        "rows_updated": 1,
        "session_id": "abc-123 (unchanged)",
        "last_seen_at": "2025-11-05 10:05:00 (updated)",
        "total_page_views": 2,
        "criteria_rankings": "Preserved from previous session",
        "tools_clicked": "Preserved and will be added to"
      }
    },
    "scenario_3_user_clears_cache": {
      "description": "Same user clears cache/cookies, then returns",
      "ip_address": "203.0.113.45 (SAME IP)",
      "steps": [
        {
          "step": 1,
          "location": "User Action",
          "action": "Clear browser cache/localStorage"
        },
        {
          "step": 2,
          "location": "Frontend",
          "action": "localStorage is empty - generate NEW session_id: 'xyz-789'"
        },
        {
          "step": 3,
          "location": "Frontend",
          "action": "Call track_page_view('xyz-789', path, ip_address, ...)"
        },
        {
          "step": 4,
          "location": "Backend (RPC)",
          "action": "Check: Does IP 203.0.113.45 exist?",
          "result": "YES - found EXISTING session_id 'abc-123'"
        },
        {
          "step": 5,
          "location": "Backend (RPC)",
          "action": "UPDATE existing row with session_id 'abc-123' (NOT 'xyz-789')",
          "note": "Backend ignores frontend's new session_id and uses existing one"
        },
        {
          "step": 6,
          "location": "Backend (RPC)",
          "action": "Return: {success: true, session_id: 'abc-123', is_new_session: false}",
          "key_point": "Returns EXISTING session_id, not the new one frontend sent"
        },
        {
          "step": 7,
          "location": "Frontend",
          "action": "Detect: returned session_id 'abc-123' != localStorage 'xyz-789'",
          "logic": "if (data.session_id !== sessionId) { ... }"
        },
        {
          "step": 8,
          "location": "Frontend",
          "action": "UPDATE localStorage: 'analytics_session_id' = 'abc-123'",
          "result": "Frontend and backend now in sync"
        },
        {
          "step": 9,
          "location": "Frontend",
          "action": "Log: 'Returning user detected - synced to existing session'",
          "console_output": "{oldSessionId: 'xyz-789', newSessionId: 'abc-123', isNewSession: false}"
        }
      ],
      "database_state": {
        "rows_created": 0,
        "rows_updated": 1,
        "duplicate_rows": 0,
        "session_id": "abc-123 (REUSED, not xyz-789)",
        "last_seen_at": "2025-11-05 12:00:00 (updated)",
        "total_page_views": 3,
        "criteria_rankings": "Preserved from first visit",
        "tools_clicked": "Preserved - will continue accumulating",
        "result": "Same record updated, NO DUPLICATION âœ…"
      }
    },
    "scenario_4_different_user_same_computer": {
      "description": "Different person uses same computer (unlikely but possible)",
      "ip_address": "203.0.113.45 (SAME IP)",
      "reality_check": "In practice, same IP = same person 95%+ of the time",
      "acceptable_limitation": "We optimize for the 95% case, not the 5% edge case",
      "what_happens": "Second person's data will merge with first person's data",
      "mitigation": "Acceptable trade-off for cleaner data and no duplicates"
    }
  },
  "implementation_details": {
    "backend_logic": {
      "file": "Supabase RPC Function: track_page_view",
      "pseudocode": [
        "1. Receive session_id from frontend",
        "2. Check if ip_address exists in database:",
        "   - Query: SELECT session_id FROM visitor_sessions WHERE ip_address = $1 ORDER BY last_seen_at DESC LIMIT 1",
        "3. IF IP EXISTS:",
        "   - UPDATE that row with new activity",
        "   - Return EXISTING session_id to frontend",
        "   - Set is_new_session = false",
        "4. IF IP DOESN'T EXIST:",
        "   - INSERT new row with provided session_id",
        "   - Return PROVIDED session_id to frontend",
        "   - Set is_new_session = true"
      ],
      "key_fields_preserved_on_update": [
        "criteria_rankings (all slider positions)",
        "guided_ranking_answers (all questionnaire responses)",
        "firmographics (company profile)",
        "tools_clicked (click counters)",
        "email (if report was sent)",
        "match_scores (final rankings)",
        "All funnel flags (is_active, has_manual_ranking, etc.)"
      ],
      "key_fields_updated_on_update": [
        "last_seen_at = NOW()",
        "total_page_views++",
        "referrer_url (most recent)",
        "utm_source/medium/campaign (most recent)",
        "user_agent (most recent)",
        "updated_at = NOW()"
      ]
    },
    "frontend_logic": {
      "file": "src/lib/analytics.ts - trackPageView()",
      "pseudocode": [
        "1. Get session_id from localStorage (or generate new UUID)",
        "2. Call backend: track_page_view(session_id, ip_address, ...)",
        "3. Backend returns: {session_id, is_new_session}",
        "4. Compare returned session_id to localStorage:",
        "   - IF SAME: Do nothing (already in sync)",
        "   - IF DIFFERENT: Update localStorage to match backend",
        "5. Log to console if returning user detected"
      ],
      "why_this_works": "Backend is source of truth for session identity via IP address"
    }
  },
  "benefits": {
    "cleaner_data": "One row per person, not one row per browser session",
    "accurate_journey": "Complete user journey even if they clear cache",
    "no_duplicates": "Same person won't inflate session counts",
    "better_analytics": "True unique visitor count",
    "cost_savings": "Fewer database rows (storage + query costs)",
    "llm_friendly": "One JSON blob per person = complete story"
  },
  "edge_cases": {
    "shared_ip_addresses": {
      "scenario": "Multiple people behind corporate NAT/proxy with same public IP",
      "impact": "Might merge different users into one record",
      "probability": "Low for B2B SaaS (most work-from-home now)",
      "mitigation": "Acceptable trade-off - optimize for common case"
    },
    "dynamic_ips": {
      "scenario": "User's IP changes (mobile network switch, VPN toggle)",
      "impact": "Will create new record",
      "probability": "Medium but expected behavior",
      "result": "Acceptable - different network context = different session"
    },
    "ip_not_available": {
      "scenario": "Privacy browser blocks IP detection",
      "impact": "Falls back to localStorage session_id only",
      "handling": "IF p_ip_address IS NULL: Skip IP check, use session_id",
      "result": "Still works, just no deduplication"
    }
  },
  "testing_scenarios": {
    "test_1_first_visit": {
      "action": "Visit site for first time",
      "expected_database": "1 new row created",
      "expected_console": "No special log (normal new session)",
      "verification": "SELECT COUNT(*) FROM visitor_sessions WHERE ip_address = 'YOUR_IP';"
    },
    "test_2_refresh_page": {
      "action": "Refresh page (localStorage intact)",
      "expected_database": "Same row updated, total_page_views++",
      "expected_console": "No special log (same session_id)",
      "verification": "SELECT total_page_views FROM visitor_sessions WHERE ip_address = 'YOUR_IP';"
    },
    "test_3_clear_cache_return": {
      "action": "Clear localStorage, close browser, return to site",
      "expected_database": "Same row updated, NO NEW ROW",
      "expected_console": "ðŸ“Š Returning user detected - synced to existing session",
      "verification": "SELECT COUNT(*) FROM visitor_sessions WHERE ip_address = 'YOUR_IP'; -- Should be 1",
      "localStorage_before": "Empty or new UUID",
      "localStorage_after": "Updated to match database session_id"
    },
    "test_4_different_computer": {
      "action": "Visit from different location (different IP)",
      "expected_database": "NEW row created (different IP = different user)",
      "expected_console": "No special log (normal new session)",
      "verification": "SELECT COUNT(*) FROM visitor_sessions; -- Should be 2 total rows"
    },
    "test_5_accumulated_data": {
      "action": "Clear cache, return, move sliders, click buttons",
      "expected_database": "Same row continues accumulating data",
      "verification": [
        "SELECT criteria_rankings FROM visitor_sessions WHERE ip_address = 'YOUR_IP'; -- Should have slider values",
        "SELECT tools_clicked FROM visitor_sessions WHERE ip_address = 'YOUR_IP'; -- Should have clicks",
        "Both from current session AND previous sessions combined"
      ]
    }
  },
  "monitoring_queries": {
    "check_deduplication_working": {
      "query": "SELECT ip_address, COUNT(*) as row_count FROM analytics.visitor_sessions WHERE ip_address IS NOT NULL GROUP BY ip_address HAVING COUNT(*) > 1;",
      "expected": "Empty result (no duplicate IPs)",
      "alert_if": "Any rows returned - deduplication might be failing"
    },
    "returning_user_rate": {
      "query": "SELECT COUNT(*) FILTER (WHERE total_page_views > 1)::float / COUNT(*) * 100 as returning_user_percentage FROM analytics.visitor_sessions;",
      "meaning": "What % of sessions are returning users (cleared cache or refreshed)",
      "benchmark": "10-30% is normal"
    },
    "average_page_views_per_user": {
      "query": "SELECT AVG(total_page_views) FROM analytics.visitor_sessions;",
      "meaning": "How many times average user interacts with tool",
      "benchmark": "2-5 page views is normal"
    }
  },
  "comparison_to_alternative_approaches": {
    "approach_1_session_id_only": {
      "description": "Every new localStorage = new row (no IP check)",
      "pros": ["Simple", "No IP privacy concerns"],
      "cons": [
        "Duplicate rows when cache cleared",
        "Inflated user counts",
        "Fragmented user journeys",
        "More storage costs"
      ],
      "verdict": "Not chosen - data quality issues"
    },
    "approach_2_ip_based_deduplication": {
      "description": "One row per IP, updated over time (CHOSEN)",
      "pros": [
        "Clean data - one record per person",
        "Complete user journey",
        "No duplicates",
        "Lower storage costs",
        "Better for LLM analysis"
      ],
      "cons": [
        "Might merge different users with same IP (rare)",
        "Slightly more complex logic"
      ],
      "verdict": "âœ… CHOSEN - optimal for most cases"
    },
    "approach_3_fingerprinting": {
      "description": "Browser fingerprint (canvas, fonts, screen) for deduplication",
      "pros": ["More unique than IP", "Works across IP changes"],
      "cons": [
        "Privacy concerns",
        "Can be blocked by privacy tools",
        "Complex implementation",
        "Still not 100% accurate"
      ],
      "verdict": "Overkill for this use case"
    },
    "approach_4_authenticated_users": {
      "description": "Require login, use user_id for deduplication",
      "pros": ["100% accurate", "Complete cross-device tracking"],
      "cons": [
        "Requires auth system",
        "Reduces conversions (login friction)",
        "Not suitable for anonymous tools"
      ],
      "verdict": "Not applicable - tool is anonymous"
    }
  },
  "privacy_compliance": {
    "gdpr_considerations": {
      "ip_address_is_pii": "Yes - IP addresses are considered personal data under GDPR",
      "legal_basis": "Legitimate interest (fraud prevention, analytics)",
      "user_rights": [
        "Right to access: Provide API endpoint for users to see their data",
        "Right to erasure: Provide /api/delete-my-data endpoint",
        "Right to rectification: Allow users to update incorrect data"
      ],
      "transparency": "Update privacy policy to explain IP-based tracking"
    },
    "ccpa_considerations": {
      "disclosure": "Privacy policy must disclose IP address collection",
      "opt_out": "Provide 'Do Not Sell My Personal Information' link",
      "data_sale": "If selling to vendors, users must be informed and can opt out"
    }
  },
  "future_enhancements": {
    "hybrid_approach": {
      "idea": "Use IP + browser fingerprint hash for even better deduplication",
      "benefit": "Handles dynamic IPs better while maintaining privacy",
      "implementation": "Already added fingerprint_hash field for future use"
    },
    "user_provided_email": {
      "idea": "Once user sends report, use email for deduplication instead of IP",
      "benefit": "Cross-device tracking for known users",
      "implementation": "UPDATE all rows with same email to merge into one"
    },
    "session_stitching": {
      "idea": "If user changes IP but we detect same browser, stitch sessions together",
      "benefit": "More accurate for mobile users",
      "implementation": "Use fingerprint_hash to link sessions"
    }
  }
}

