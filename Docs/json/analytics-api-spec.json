{
  "schema_version": "1.0.0",
  "last_updated": "2025-11-08T22:00:00Z",
  "type": "API_SPECIFICATION",
  "metadata": {
    "project": "PPM Tool Finder",
    "maintainer": "Parker Gawne",
    "mcp_compatible": true,
    "purpose": "API endpoints and query patterns for new analytics schema"
  },
  "database_connection": {
    "platform": "Supabase",
    "project_id": "vfqxzqhitumrxshrcqwr",
    "schema": "analytics",
    "authentication": "Supabase JWT tokens or service role key"
  },
  "core_tables": {
    "analytics.users": {
      "description": "Core user sessions table",
      "primary_key": "id (UUID)",
      "unique_constraints": ["session_id"],
      "common_queries": {
        "get_user_by_session": {
          "query": "SELECT * FROM analytics.users WHERE session_id = $1",
          "parameters": ["session_id (text)"],
          "use_case": "Retrieve user data for active session"
        },
        "get_active_users": {
          "query": "SELECT * FROM analytics.users WHERE is_active = true AND last_seen_at > NOW() - INTERVAL '24 hours'",
          "parameters": [],
          "use_case": "Dashboard showing recent active users"
        },
        "get_users_with_reports": {
          "query": "SELECT * FROM analytics.users WHERE has_sent_report = true ORDER BY updated_at DESC",
          "parameters": [],
          "use_case": "List of users who requested email reports"
        }
      }
    },
    "analytics.questions": {
      "description": "Dynamic questions for guided ranking",
      "primary_key": "id (UUID)", 
      "indexes": ["question_order", "is_active"],
      "common_queries": {
        "get_active_questions": {
          "query": "SELECT * FROM analytics.questions WHERE is_active = true ORDER BY question_order",
          "parameters": [],
          "use_case": "Load current guided ranking questions for frontend"
        },
        "get_question_with_choices": {
          "query": "SELECT q.*, array_agg(qc.* ORDER BY qc.choice_order) as choices FROM analytics.questions q LEFT JOIN analytics.question_choices qc ON q.id = qc.question_id WHERE q.id = $1 GROUP BY q.id",
          "parameters": ["question_id (UUID)"],
          "use_case": "Get complete question with all answer choices"
        }
      }
    },
    "analytics.question_choices": {
      "description": "Answer options for questions",
      "primary_key": "id (UUID)",
      "foreign_keys": ["question_id -> analytics.questions.id"],
      "common_queries": {
        "get_choices_for_question": {
          "query": "SELECT * FROM analytics.question_choices WHERE question_id = $1 AND is_active = true ORDER BY choice_order",
          "parameters": ["question_id (UUID)"],
          "use_case": "Load answer choices for specific question"
        }
      }
    }
  },
  "junction_tables": {
    "analytics.user_question_responses": {
      "description": "Individual user responses to questions",
      "primary_key": "id (UUID)",
      "unique_constraints": ["(user_id, question_id)"],
      "insert_patterns": {
        "record_response": {
          "query": "INSERT INTO analytics.user_question_responses (user_id, question_id, question_choice_id, response_timestamp) VALUES ($1, $2, $3, NOW()) ON CONFLICT (user_id, question_id) DO UPDATE SET question_choice_id = EXCLUDED.question_choice_id, response_timestamp = EXCLUDED.response_timestamp",
          "parameters": ["user_id (UUID)", "question_id (UUID)", "question_choice_id (UUID)"],
          "use_case": "Record or update user's answer to a question"
        }
      },
      "query_patterns": {
        "get_user_responses": {
          "query": "SELECT uqr.*, q.question_text, qc.choice_text FROM analytics.user_question_responses uqr JOIN analytics.questions q ON uqr.question_id = q.id JOIN analytics.question_choices qc ON uqr.question_choice_id = qc.id WHERE uqr.user_id = $1 ORDER BY q.question_order",
          "parameters": ["user_id (UUID)"],
          "use_case": "Get all responses for a user"
        }
      }
    },
    "analytics.user_criteria_responses": {
      "description": "User ratings for criteria (1-5 scale)",
      "primary_key": "id (UUID)",
      "unique_constraints": ["(user_id, criteria_id)"],
      "insert_patterns": {
        "record_criteria_rating": {
          "query": "INSERT INTO analytics.user_criteria_responses (user_id, criteria_id, rating, response_timestamp) VALUES ($1, $2, $3, NOW()) ON CONFLICT (user_id, criteria_id) DO UPDATE SET rating = EXCLUDED.rating, response_timestamp = EXCLUDED.response_timestamp",
          "parameters": ["user_id (UUID)", "criteria_id (UUID)", "rating (integer 1-5)"],
          "use_case": "Record or update user's criteria rating"
        }
      }
    },
    "analytics.user_tool_actions": {
      "description": "Tool interaction tracking for monetization",
      "primary_key": "id (UUID)",
      "no_unique_constraints": "Multiple actions per user-tool pair allowed",
      "action_types": ["click", "view_details", "compare", "try_free"],
      "insert_patterns": {
        "record_tool_action": {
          "query": "INSERT INTO analytics.user_tool_actions (user_id, tool_id, action_type, position, match_score, context) VALUES ($1, $2, $3, $4, $5, $6)",
          "parameters": ["user_id (UUID)", "tool_id (UUID)", "action_type (text)", "position (integer)", "match_score (numeric)", "context (jsonb)"],
          "use_case": "Track every tool interaction for analytics and monetization"
        }
      }
    }
  },
  "rollup_views": {
    "analytics.tool_action_rollups": {
      "description": "Aggregated tool performance metrics",
      "refresh": "Real-time view (no materialization)",
      "key_metrics": [
        "unique_clicks", "total_clicks",
        "unique_detail_views", "total_detail_views", 
        "unique_comparisons", "total_comparisons",
        "unique_try_free", "total_try_free",
        "avg_match_score", "avg_position"
      ],
      "query_patterns": {
        "get_top_performing_tools": {
          "query": "SELECT * FROM analytics.tool_action_rollups ORDER BY unique_try_free DESC, unique_clicks DESC LIMIT 10",
          "use_case": "Dashboard showing most engaged-with tools"
        },
        "get_tool_performance": {
          "query": "SELECT * FROM analytics.tool_action_rollups WHERE tool_id = $1",
          "parameters": ["tool_id (UUID)"],
          "use_case": "Individual tool performance report"
        }
      }
    },
    "analytics.question_response_rollups": {
      "description": "Question effectiveness metrics",
      "key_metrics": ["total_responses", "response_count"],
      "query_patterns": {
        "get_question_completion_rates": {
          "query": "SELECT * FROM analytics.question_response_rollups ORDER BY question_order",
          "use_case": "Analyze which questions users skip or complete"
        }
      }
    },
    "analytics.user_activity_rollups": {
      "description": "User engagement summaries",
      "key_metrics": [
        "questions_answered", "criteria_rated",
        "tools_interacted_with", "total_tool_actions"
      ],
      "query_patterns": {
        "get_user_engagement_segments": {
          "query": "SELECT CASE WHEN questions_answered >= 10 THEN 'High Engagement' WHEN questions_answered >= 5 THEN 'Medium Engagement' ELSE 'Low Engagement' END as segment, COUNT(*) FROM analytics.user_activity_rollups GROUP BY 1",
          "use_case": "User segmentation for marketing"
        }
      }
    }
  },
  "posthog_integration": {
    "replacement_queries": {
      "unique_viewers": {
        "old_approach": "PostHog page view events with distinct_id counting",
        "new_approach": "SELECT COUNT(DISTINCT session_id) FROM analytics.users WHERE first_seen_at >= $1",
        "benefits": "More accurate unique user counting, no duplicate session issues"
      },
      "conversion_funnel": {
        "stages": [
          "visited_site: COUNT(*) FROM analytics.users",
          "started_ranking: COUNT(*) FROM analytics.users WHERE has_partial_ranking = true OR has_full_ranking = true",
          "completed_ranking: COUNT(*) FROM analytics.users WHERE has_full_ranking = true", 
          "sent_report: COUNT(*) FROM analytics.users WHERE has_sent_report = true"
        ]
      }
    }
  },
  "vector_database_preparation": {
    "description": "Schema designed for future LLM integration",
    "embedding_candidates": {
      "user_profiles": {
        "table": "analytics.user_activity_rollups",
        "embedding_source": "Concatenated user preferences and behavior patterns",
        "use_case": "Similar user recommendations and personalization"
      },
      "tool_performance": {
        "table": "analytics.tool_action_rollups", 
        "embedding_source": "Tool interaction patterns and user engagement metrics",
        "use_case": "Tool recommendation engine and performance insights"
      },
      "question_responses": {
        "table": "analytics.user_question_responses with joins",
        "embedding_source": "User response patterns across all questions",
        "use_case": "Match score explanation and user preference analysis"
      }
    }
  },
  "performance_considerations": {
    "indexing_strategy": [
      "Primary keys on all tables for fast lookups",
      "Foreign key indexes for join performance", 
      "Composite indexes on common query patterns",
      "Specialized indexes on rollup view underlying tables"
    ],
    "query_optimization": [
      "Use rollup views instead of raw junction table aggregations",
      "Batch insert patterns for high-volume data ingestion",
      "Proper WHERE clause ordering for index utilization"
    ],
    "scaling_considerations": [
      "Junction tables will grow linearly with user engagement",
      "Consider partitioning user_tool_actions by date for very large datasets",
      "Rollup views may need materialization for sub-second response times"
    ]
  },
  "migration_queries": {
    "data_verification": {
      "check_migration_completeness": "SELECT 'users' as table_name, COUNT(*) as count FROM analytics.users UNION ALL SELECT 'user_question_responses', COUNT(*) FROM analytics.user_question_responses UNION ALL SELECT 'user_criteria_responses', COUNT(*) FROM analytics.user_criteria_responses",
      "compare_old_vs_new": "SELECT (SELECT COUNT(*) FROM analytics.visitor_sessions) as old_count, (SELECT COUNT(*) FROM analytics.users) as new_count"
    }
  }
}
